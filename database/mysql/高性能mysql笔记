1. mvcc 多版本并发控制
	## 功能 不阻塞读，锁定必要的行
	## innodb的实现
		### 在每行的记录后面加上两列，记录行创建时的事务版本号和删除时的事务版本号
		### 查找数据时，只查找事务早于或等于当前事务版本的数据，保证数据是事务开始前就存在，或者是当前事务插入或者删除的，
		如果数据有删除标识，只查找删除标识的事务版本号大于当前版本的数据，保证数据在事务开始之前未被删除
		### insert数据时，当前系统版本号作为行版本号
		### 删除数据时，当前系统版本号作为删除标识
		### 更新数据时，插入一条新纪录，当前系统版本作为行版本号，当前系统版本作为旧数据的删除标识

2. 列不能设置为null
	## 占更多空间
	## count列时，是不统计null值的
	## null值与任何值运算都是null

3. sql语句优化
	## 列不为null
	## 索引字段进行运算使索引失效
	## 模糊搜索使用左匹配
	## 

4. explain
	## select_type
		### SIMPLE 简单查询，没有子查询和union查询
		### PRIMARY 查询中包含任何复杂的子部分，最外层查询被标记为PRIMARY
		### SUBQUERY 在SELECT或WHERE列表中包含了子查询
		### DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生），MySQL会递归执行这些子查询，把结果放在临时表中
		### UNION 若第二个SELECT出现在UNION之后，则被标记为UNION：若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED
		### UNION RESULT 从UNION表获取结果的SELECT
	## table 
		### 当前执行的表
	## type
		### const 主键索引或者是unique索引查询
		### ref 非唯一索引查询
		### range 索引范围查询
		### index Full Index Scan，Index与All区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘读取的）
		### all  Full Table Scan 将遍历全表以找到匹配的行
	## possible_keys 
		### 显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。
	## key
		### 实际使用的索引，如果为NULL，则没有使用索引。（可能原因包括没有建立索引或索引失效）
		### 查询中若使用了覆盖索引（select 后要查询的字段刚好和创建的索引字段完全相同），则该索引仅出现在key列表中
	### key_len
		### 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好。key_len显示的值为索引字段的最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的
	## ref
		### 显示索引的那一列被使用了，如果可能的话，最好是一个常数。哪些列或常量被用于查找索引列上的值
	## rows
		### 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数，也就是说，用的越少越好 
	## Extra 包含不适合在其他列中显式但十分重要的额外信息
		### Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”
		### 



